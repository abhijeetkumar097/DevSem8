Minikube CLI -> for start up/deleting the cluster

minikube version
minikube start --driver=virtualbox
minikube start --driver=docker

Kubectl CLI -> for configuring the minikube cluster

kubectl version
kubectl get nodes
kubectl get pod
kubectl get services
kubectl create deployment NAME --image=image [--dry-run] [options]
kubectl create deployment nginx-depl --image=nginx
kubectl get replicaset
kubectl edit deployment nginx-depl
kubectl logs [pod name]
kubectl describe pod [pod name]  (to get the additional information when the container are starting like state change)
kubectl exec -it [pod name] --bin/bash
kubectl get deployment
kubectl describe service [service name]
kubectl delete deployment [deployment name]
kubectl apply -f config-file.yml
kubectl get pod -o wide
kubectl delete -f demo.yaml
kubectl get all
kubectl get pod --watch

---
kubectl rollout restart deployment mongo-express
kubectl scale deployment mongo-express --replicas=0

Theory

Pod is the smallest unit, Deployment -> abstraction over Pods
[pod name] -> name-replica_set_id-its_own_id
kubectl create deployment NAME --image=image option1 option2 -> this is usually contains all the configuration which is  impractical so we use configuration file

Layers of Abstraction
1.	Deployment manages a..
2.	ReplicaSet manages a ..
3.	Pod is an abstraction of ..
4.	Container

apiVersion:
kind:
Each configuration file has 3 parts
1.	metadata -> contains metadata like name
2.	specification -> specific to the kind of the component
3.	status -> automatically generated by Kubernetes it uses the state to state to compare the desired and the actual state and the this is the basis of self healing that Kubernetes provides and this status info comes from etcd (cluster brain i.e. one the master components)

edcd -> holds at any time the current status of any k8s component


Labels & Selectors -> the way connection is established

Metadata -> contains labels its a key-value pair and which ever pods have that it means it belongs to that deployment(connecting Deployment to pods).
spec(specification) -> contains selectors

Connecting Deployment to Pods
1.	Pods get the label through the template blueprint
2.	This label is matched by the selector(selector.matchLabels.app = nginx)





Browser request flow trought k8

Browser -> Mongo Express External Service -> Mongo Express Pod -> Mongo DB internal service -> Mongo DB Pod (here authenticate the pod using the secret credentials)



Secret configuration file

-kind : Secret
-metadata/name: a random name
-type: Opaque - default for arbitrary key-value pairs
-data: the actual contents in key-value pairs

Eg:
apiVersion: v1
kind: Secret
metadata:
  name: mongodb-secret
type: Opaque
data:
  mongo-root-username: base64 encoded
  mongo-root-password: base64 encoded


to apply : kubectl apply -f mongo-secret.yaml


--- (three dash is used for document separation in yaml rather than creating multiple file)

Namespaces

kubectl get namepace
kubectl cluster-info
kubectl api-resources --namespaced=false  (to get the resources which are not bound to namespace)
kubectl apply -f demo.yml --namespace=my-namespace  (to put this in particular name space this can also be done in yml file itself.
kubectl get configmap -n my-namespace
kubectl get configmap ( is same as kubectl get configmap -n default)
kubectl get configmap -o wide (name space is default by default)
kubectl get configmap -o yaml (name space is default by default)
kube

⦁	Services can be accessed inside other namespace.
⦁	Namespace must have ConfigMap and Secret of their own, it can not be accessed from other namespaces.
⦁	Resources(volume, node) cannot be created inside a namespace.


Ingress

Ingress Controller

We need an implementation for ingress and that is called ingress controller. We need to install it. It is basically another bod or another set of pods that run on node in Kubernetes cluster and thus evaluation and processing of ingress rules so the yaml.
and
1.	evaluates all the rules (networking rules)
2.	manages redirections
3.	entry point to cluster

minikube addons enable ingress  (to enable ingress Controller)
to check (kubectl get pod -n kube-system)


On cloud platform
we can use it own build in load balancer and this will redirect the request to ingress controller

On bare Metal:
We need to configure some kind of entry point
1.	Proxy Server -> it can be software or hardware solutions that will take a role of entry point, it will have a public IP address and open ports and this one will be the only one accessible externally so none of the servers in Kubernetes will be have publicly accessible IP address.

kubectl has a k8-dashborad, internal service and pods are already. So we can configure external service or ingress rule.

kubectl get ns
kubectl get all -n kubernetes-dashboard (shows all the component in Kubernetes dashboard
kubectl describe ingress -n test-namespace
kubectl get ingress -n test-namespace --watch (to get ip)
or minikube ip

then in /etc/hosts -> ip host.com(host in ingress file)

there is a default backend in k8 in case service is not defined. And it will return default error response like if path i.e. not configured if we try to access that it will give 404 page not found.


we can define multiple path(/ or /shopping) or multiple host(sub domain) like (analytics.myapp.com and shopping.myapp.com)

t
